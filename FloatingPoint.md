</br>

# Representable Numbers

</br>

<p>There are two limitations to using binary to reprensent floating point numbers:</p>

<p><b>Limitation #1</b> : Can only exactly represent numbers of the form x / 2^kï¼Œ<b>Other rational numbers have repeating bit representations</b>.For example:</p>

```
Value      Representation
1 / 3      0.010101010101[01]...
1 / 5      0.001100110011[0011]...
1 / 10     0.0001100110011[0011]...
```

<p><b>Limitation #2</b> : Just one setting of binary point within the w bits. Limited range of numbers</p>

<p>There's only so many bits to the left and the right of the binary point. So if we move the binary point to the left. Then we can't represent as many large numbers. We can only represent small numbers. But we have more precision to the right of the binary point. So we can represent more fractional values. Just the range of those values will be mush smaller</p>

<p>Similiar, if we move the binary to the right. We'll have a larger range of values.</p>

<p>Therefore, floating point is chosen as a compromise representation method</p>

<p>So, floating point is a representation to try that enables us to move that binary point to represent sort of as wide a range as possible, with as much precision given the number of bits</p>

<p>So the floating point is this sort of shifting binary point</p>

</br>

# Floating Point Representation

</br>

<p><b>Numerical Form</b>: `(-1)^s M 2^E`</p>

- Sign bit s determines whether number is negative or positive

- Significand M (mantissa) normally a fractional value in range [1.0, 2.0)

- Exponent E weights value by power of two

<p>It represents numbers in a way like a scientific notation. All of the numbers that we can represent in floating point have to be represented in this form</p> 

<p><b>Encoding</b>:(in either 32-bit or 64-bit)</p>

- MSB S is sign bit s

- exp field encodes E (but is not equal to E)

- frac field encodes M (but is not equal to E)

![14ad95ea3ef21c47c6f6b8849fa91a66](https://github.com/user-attachments/assets/d2584ae2-986b-41ad-a89b-c6d2df706dd0)

<p><b>Precision options</b></p>

```
Single precision: 32 bits
s     -  1-bits
exp   -  8-bits
frac  -  32-bits
Single precision: 64 bits
s     -  1-bits
exp   -  11-bits
frac  -  52-bits
Extended precision: 80 bits (Intel only)
s     -  1-bits
exp   -  15-bits
frac  -  63 or 64-bits
```

<p><b>Normalized Values</b></p>

- When: exp != 000...0 and exp != 111...1. Not equal to all zeros and all ones. All zeros and all ones are special kinds of numbers we'll look at a second

- Exponent coded as a biased value E = exp - bias

  1. exp: unsigned value of exp field
 
  2. bias = 2^(k-1) - 1, where k is number of exponent bits. Single precision : 127(exp: 1...254, E: -126...127). Double precision : 1024(exp: 1...2046, E: -1022...1023).

<p>We have exponents that are negative and positive. So why not just use a two's complement in the exp field to represent those positive and negative exponents. If we encode the exponent E using this bias representation. The smallest negative exponent is representated by all zeros, And the largest exponent is representated by 01...111</p>

<p></p>







































































































































































































































































































































































































































































































































































