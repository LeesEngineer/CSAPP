</br>

# Overview

</br>

<p>Optimizing Compilers</p>

- Provide efficient mapping of program to machine

  1. register allocation
 
  2. code selection and ordering (scheduling)
 
  3. dead code elimination
 
  4. eliminating minor inefficiencies

- Don't (usually) improve asymptotic effeciency

  1. up to programmer to select best overall algorithm
 
  2. big-O savings are (often) more important than constant factors

- Have difficulty overcoming "optimization blocks"

  1. potential memory "aliasing"
 
  2. potential procedure side-effect
 
<p>Limitations of optimizing compiler : Compiler has a whole cookbook of optimization strategies. But in general if compiler feels like the code is something that It doesn't feel confident about being able to make certain transformations, it just won't and it will keep things a more direct implementation of exactly what you described.</p>

- Operate under fundamental constraint

  1. Must not cause any change in program behavior. Except, possibly when program making use of nonstandard language features

  2. Often prevents it from making optimizations that would only affect behavior under pathological conditions.

- Behavior that may be obvious to the programmer can be obfuscated by languages and coding styles

  1. e.g., Data ranges may be more limited 








































































































































































































































































































































































































































































































